<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>NextPlayer‚Ñ¢ ‚Äì Scouting App</title>

  <!-- PWA & Mobil -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#050608" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="NextPlayer-192.png" />
  <link rel="apple-touch-icon" href="NextPlayer-512.png" />

  <style>
    :root {
      --np-bg: #050608;
      --np-card: #ffffff;
      --np-accent: #f5b642;
      --np-text: #111111;
      --np-muted: #666666;
    }

    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      background: #f1f1f1;
      color: var(--np-text);
    }

    header {
      background: linear-gradient(135deg, #000000, #151515);
      color: #fff;
      padding: 14px 18px 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    header h1 {
      margin: 0;
      font-size: 1.3rem;
      letter-spacing: 0.03em;
    }

    header .subtitle {
      margin: 4px 0 0;
      font-size: 0.8rem;
      color: #c0c0c0;
    }

    .top-nav {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .top-nav button {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.4);
      color: #f5f5f5;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.75rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .top-nav button.active {
      background: var(--np-accent);
      border-color: var(--np-accent);
      color: #111;
      font-weight: 600;
    }

    main {
      padding: 16px;
      max-width: 1100px;
      margin: 0 auto 40px;
    }

    .section-card {
      background: var(--np-card);
      border-radius: 10px;
      padding: 14px 14px 16px;
      margin-bottom: 16px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid rgba(0,0,0,0.04);
    }

    .section-card h2 {
      margin-top: 0;
      padding-bottom: 4px;
      border-bottom: 2px solid rgba(0,0,0,0.06);
      font-size: 1rem;
    }

    .section-card h2 span {
      border-left: 4px solid var(--np-accent);
      padding-left: 6px;
    }

    h3 {
      margin-top: 14px;
      margin-bottom: 6px;
      font-size: 0.95rem;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    label {
      display: inline-block;
      min-width: 140px;
      font-size: 0.9rem;
    }

    input, select, textarea, button {
      padding: 4px 6px;
      font-size: 0.9rem;
    }

    input, select, textarea {
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    button {
      border-radius: 4px;
      border: 1px solid #ccc;
      cursor: pointer;
      background: #f3f3f3;
    }

    button.primary {
      background: var(--np-accent);
      border-color: var(--np-accent);
      color: #111;
      font-weight: 600;
    }

    textarea {
      width: 100%;
      max-width: 600px;
      min-height: 60px;
    }

    .status-line {
      margin-top: 5px;
      font-size: 0.8rem;
      color: var(--np-muted);
    }

    #criteria > div {
      margin-bottom: 6px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 900px;
      background: #fff;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      font-size: 0.8rem;
      text-align: left;
    }

    th {
      background: #f5f5f5;
    }

    .fav-toggle {
      cursor: pointer;
      font-size: 1rem;
    }

    @media (max-width: 700px) {
      main { padding: 10px; }
      label { min-width: 110px; }
      .row { gap: 6px; }
      header h1 { font-size: 1.1rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>NextPlayer‚Ñ¢ ‚Äì Scouting App</h1>
    <div class="subtitle">Bewertungen sammeln, Ranking sehen, Talente entdecken.</div>

    <div class="top-nav">
      <button data-target="sec-config"  class="active">Setup</button>
      <button data-target="sec-auth">Login</button>
      <button data-target="sec-profile">Profil</button>
      <button data-target="sec-rating">Bewerten</button>
      <button data-target="sec-ranking">Ranking</button>
      <button data-target="sec-events">Events</button>
      <button data-target="sec-last">Verlauf</button>
    </div>
  </header>

  <main>

    <!-- 1. Supabase-Konfiguration -->
    <section id="sec-config" class="section-card">
      <h2><span>1. Supabase-Konfiguration</span></h2>
      <div class="row">
        <label for="sb-url">Supabase URL</label>
        <input id="sb-url" type="text" size="40" placeholder="https://xxxx.supabase.co">
      </div>
      <div class="row">
        <label for="sb-key">Anon Key</label>
        <input id="sb-key" type="text" size="60" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...">
      </div>
      <div class="row">
        <button id="btn-save-conf">Speichern</button>
        <button id="btn-test-conf">Verbindung testen</button>
      </div>
      <div id="conf-msg" class="status-line"></div>
    </section>

    <!-- 2. Login / Registrierung -->
    <section id="sec-auth" class="section-card">
      <h2><span>2. Login / Registrierung</span></h2>

      <h3>Login & Grunddaten</h3>
      <div class="row">
        <label for="auth-email">E-Mail</label>
        <input id="auth-email" type="email" size="30">
      </div>
      <div class="row">
        <label for="auth-pass">Passwort</label>
        <input id="auth-pass" type="password" size="20">
      </div>

      <h3>Nur f√ºr Registrierung (Konto anlegen)</h3>
      <div class="row">
        <label for="reg-nick">K√ºnstlername</label>
        <input id="reg-nick" type="text" size="20" placeholder="z.B. NextLeo10">
      </div>
      <div class="row">
        <label for="reg-year">Geburtsjahr</label>
        <input id="reg-year" type="number" min="2000" max="2100" size="6" placeholder="z.B. 2010">
      </div>
      <div class="row">
        <label for="reg-parent-email">Eltern-E-Mail</label>
        <input id="reg-parent-email" type="email" size="30" placeholder="Pflicht bei U16, optional sonst">
      </div>
      <div class="row">
        <label for="reg-role">Rolle</label>
        <select id="reg-role">
          <option value="">Bitte w√§hlen‚Ä¶</option>
          <option value="spieler">Aktiver Spieler</option>
          <option value="trainer">Trainer</option>
          <option value="scout">Scout</option>
          <option value="eltern">Elternteil</option>
          <option value="zuschauer">Zuschauer / Fan</option>
          <option value="sonstige">Sonstige</option>
        </select>
      </div>

      <div class="status-line">
        Unter 16 Jahren ist eine Zustimmung eines Erziehungsberechtigten erforderlich.  
        Ein Konto ist bis zur Zustimmung ‚Äûgesperrt‚Äú.
      </div>

      <div class="row">
        <button id="btn-signup">Registrieren</button>
        <button id="btn-login">Login</button>
        <button id="btn-logout">Logout</button>
      </div>

      <div class="status-line">
        <span id="auth-user"></span>
      </div>
      <div id="auth-lock-info" class="status-line"></div>
      <div id="auth-msg" class="status-line"></div>
      <div id="auth-approval-link" class="status-line"></div>
    </section>

    <!-- 2b. Profil / Rolle -->
    <section id="sec-profile" class="section-card">
      <h2><span>2b. Profil / Rolle</span></h2>
      <div class="row">
        <label for="prof-role">Rolle</label>
        <select id="prof-role">
          <option value="">Bitte w√§hlen‚Ä¶</option>
          <option value="trainer">Trainer</option>
          <option value="spieler">Aktiver Spieler</option>
          <option value="scout">Scout</option>
          <option value="eltern">Elternteil</option>
          <option value="zuschauer">Zuschauer / Fan</option>
          <option value="sonstige">Sonstige</option>
        </select>
      </div>
      <div class="row">
        <label for="prof-club" id="prof-club-label">Verein (optional)</label>
        <input id="prof-club" type="text" size="30">
      </div>
      <div class="row">
        <label for="prof-extra" id="prof-extra-label">Zusatzinfo (optional)</label>
        <input id="prof-extra" type="text" size="40" placeholder="">
      </div>
      <div class="row">
        <button id="btn-save-profile" type="button">Profil speichern</button>
      </div>
      <div id="prof-msg" class="status-line"></div>
    </section>

    <!-- 2a. Spieler anlegen + 3. Bewertung & Events -->
    <section id="sec-rating" class="section-card">
      <h2><span>2a. Spieler & 3. Bewertung</span></h2>

      <h3>2a. Spieler anlegen (manuell)</h3>
      <div class="row">
        <label for="pl-first">Vorname</label>
        <input id="pl-first" type="text" size="20">
      </div>
      <div class="row">
        <label for="pl-last">Nachname</label>
        <input id="pl-last" type="text" size="20">
      </div>
      <div class="row">
        <label for="pl-birth">Geburtsdatum</label>
        <input id="pl-birth" type="date">
      </div>
      <div class="row">
        <label for="pl-club-current">Aktueller Verein</label>
        <input id="pl-club-current" type="text" size="30" placeholder="z.B. FC 08 Villingen U17">
      </div>
      <div class="row">
        <label for="pl-club-prev">Verein vorher</label>
        <input id="pl-club-prev" type="text" size="30" placeholder="z.B. SC Freiburg Jugend">
      </div>
      <div class="row">
        <label for="pl-pos">Position(en)</label>
        <select id="pl-pos" multiple size="6">
          <option value="TW">TW (Torwart)</option>
          <option value="AV">AV (Au√üenverteidiger)</option>
          <option value="IV">IV (Innenverteidiger)</option>
          <option value="MF">MF (Mittelfeld)</option>
          <option value="AST">AST (Au√üenst√ºrmer)</option>
          <option value="MST">MST (Mittelst√ºrmer)</option>
        </select>
        <span style="font-size:0.8rem;">Strg/Cmd gedr√ºckt halten f√ºr Mehrfachauswahl.</span>
      </div>

      <div class="row">
        <label for="pl-foot">Starker Fu√ü</label>
        <select id="pl-foot">
          <option value="">Bitte w√§hlen‚Ä¶</option>
          <option value="left">links</option>
          <option value="right">rechts</option>
          <option value="both">beidf√º√üig</option>
        </select>
      </div>

      <div class="row">
        <button id="btn-create-player" type="button">Spieler speichern</button>
      </div>
      <div id="player-create-msg" class="status-line"></div>

      <h3>3. Bewertung erfassen</h3>
      <div class="row">
        <label for="r-player">Spieler</label>
        <select id="r-player"></select>
      </div>
      <div class="row">
        <label for="r-event">Event</label>
        <select id="r-event"></select>
      </div>

      <h3>Kriterien (Schulnoten 1‚Äì6)</h3>
      <div id="criteria"></div>

      <h3>Kommentar</h3>
      <textarea id="r-comment" placeholder="Kurze Beschreibung der Leistung..."></textarea>
      <div class="row">
        <button id="btn-add-rating">Bewertung speichern</button>
      </div>
      <div id="rate-msg" class="status-line"></div>

      <h3>3b. Ereignis suchen</h3>
      <div class="row">
        <label for="search-pairing">Paarung / Spiel</label>
        <input id="search-pairing" type="text" size="40"
          placeholder="z.B. FC 08 Villingen - SC Freiburg U17" />
        <button id="btn-search-event" type="button">Suchen</button>
      </div>
      <div id="event-results"></div>

      <p id="event-current" style="font-size:0.9rem; color:#555; margin-top:10px;">
        Kein Spiel ausgew√§hlt.
      </p>

      <h3>3d. Event-Details</h3>
      <div id="event-card" style="
        background:#fff;
        border-radius:8px;
        padding:10px 14px;
        box-shadow:0 1px 3px rgba(0,0,0,0.12);
        max-width:600px;
        font-size:0.9rem;
      ">
        <p style="margin:0; color:#555;">Kein Spiel ausgew√§hlt.</p>
      </div>

      <h3>3c. Event anlegen</h3>
      <div class="row">
        <label for="event-date">Datum</label>
        <input id="event-date" type="date">
      </div>
      <div class="row">
        <label for="event-type">Event-Typ</label>
        <select id="event-type">
          <option value="match">Spiel</option>
          <option value="training">Training</option>
          <option value="tournament">Turnier</option>
        </select>
      </div>
      <div class="row">
        <label for="event-home">Heimteam</label>
        <input id="event-home" type="text" size="30" placeholder="z.B. FC 08 Villingen U17">
      </div>
      <div class="row">
        <label for="event-away">Ausw√§rtsteam</label>
        <input id="event-away" type="text" size="30" placeholder="z.B. SC Freiburg U17">
      </div>
      <div class="row">
        <label for="event-name">Name</label>
        <input id="event-name" type="text" size="40" placeholder="z.B. Oberliga-Heimspiel oder Testspiel">
      </div>
      <div class="row">
        <label for="event-location">Ort</label>
        <input id="event-location" type="text" size="40" placeholder="z.B. Kunstrasen Villingen">
      </div>
      <div class="row">
        <button id="btn-create-event" type="button">Event speichern</button>
      </div>
      <div id="event-create-msg" class="status-line"></div>
    </section>

    <!-- 4. Ranking -->
    <section id="sec-ranking" class="section-card">
      <h2><span>4. Ranking</span></h2>
      <div class="row">
        <label for="club-filter">Verein</label>
        <select id="club-filter"></select>
      </div>
      <div class="row">
        <label for="rank-pos">Position</label>
        <select id="rank-pos">
          <option value="">Alle</option>
          <option value="TW">TW</option>
          <option value="AV">AV</option>
          <option value="IV">IV</option>
          <option value="MF">MF</option>
          <option value="AST">AST</option>
          <option value="MST">MST</option>
        </select>

        <label for="rank-foot">Starker Fu√ü</label>
        <select id="rank-foot">
          <option value="">Alle</option>
          <option value="left">links</option>
          <option value="right">rechts</option>
          <option value="both">beidf√º√üig</option>
        </select>
      </div>
      <div class="row">
        <label for="rank-type">Event-Typ</label>
        <select id="rank-type">
          <option value="">Alle</option>
          <option value="match">Spiel</option>
          <option value="training">Training</option>
          <option value="tournament">Turnier</option>
        </select>
      </div>
      <div class="row">
        <label for="rank-role">Bewertungs-Rolle</label>
        <select id="rank-role">
          <option value="">Alle</option>
          <option value="trainer">Trainer</option>
          <option value="scout">Scout</option>
          <option value="eltern">Eltern</option>
          <option value="spieler">Mitspieler</option>
          <option value="sonstige">Sonstige</option>
        </select>
      </div>
      <div class="row">
        <label for="rank-from">Von Datum</label>
        <input id="rank-from" type="date">
        <label for="rank-to">Bis Datum</label>
        <input id="rank-to" type="date">
      </div>
      <div class="row">
        <label for="rank-min">Min. Bewertungen</label>
        <input id="rank-min" type="number" value="1" min="0" style="width:70px;">
      </div>
      <div class="row">
        <label for="rank-q">Suche (Name/Verein)</label>
        <input id="rank-q" type="text" size="30">
      </div>
      <div class="row">
        <label for="fav-filter">Watchlist</label>
        <select id="fav-filter">
          <option value="">Alle</option>
          <option value="fav">Nur Favoriten</option>
        </select>
        <label>
          <input type="checkbox" id="rank-top10">
          nur Top 10
        </label>
        <button id="btn-refresh-ranking">Ranking aktualisieren</button>
        <button id="btn-export-csv">CSV-Export</button>
      </div>
      <div id="rank-msg" class="status-line"></div>

      <table id="rank-table">
        <thead>
          <tr>
            <th>‚òÖ</th>
            <th>Spieler</th>
            <th>Verein</th>
            <th>Pos</th>
            <th>Fu√ü</th>
            <th>#Bewertungen</th>
            <th>√ò Note</th>
            <th>Letztes Event</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="8">Noch keine Daten.</td></tr>
        </tbody>
      </table>
    </section>

    <!-- 5. Kalender-Import (ICS) -->
    <section id="sec-events" class="section-card">
      <h2><span>5. Kalender-Import (ICS)</span></h2>
      <div class="row">
        <label for="ics-file">ICS-Datei</label>
        <input id="ics-file" type="file" accept=".ics">
        <button id="btn-import-ics">Datei importieren</button>
      </div>
      <div class="row">
        <label for="ics-url">ICS-URL</label>
        <input id="ics-url" type="text" size="60" placeholder="https://.../kalender.ics">
        <button id="btn-import-ics-url">Von URL laden</button>
      </div>
      <div id="ics-msg" class="status-line"></div>
    </section>

    <!-- 6. Letzte Bewertungen -->
    <section id="sec-last" class="section-card">
      <h2><span>6. Letzte Bewertungen</span></h2>
      <table>
        <thead>
          <tr>
            <th>Datum</th>
            <th>Spieler</th>
            <th>Event</th>
            <th>Kommentar</th>
          </tr>
        </thead>
        <tbody id="last-ratings">
          <tr><td colspan="4">Noch keine Bewertungen.</td></tr>
        </tbody>
      </table>
    </section>
  </main>

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .catch(err => console.error('SW registration failed:', err));
    }
  </script>

  <!-- Navigation -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const buttons = Array.from(document.querySelectorAll('.top-nav button'));
      const sections = {
        'sec-config':  document.getElementById('sec-config'),
        'sec-auth':    document.getElementById('sec-auth'),
        'sec-profile': document.getElementById('sec-profile'),
        'sec-rating':  document.getElementById('sec-rating'),
        'sec-ranking': document.getElementById('sec-ranking'),
        'sec-events':  document.getElementById('sec-events'),
        'sec-last':    document.getElementById('sec-last')
      };

      function showSection(id) {
        Object.entries(sections).forEach(([key, el]) => {
          if (!el) return;
          el.style.display = (key === id) ? 'block' : 'none';
        });
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.target === id);
        });
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }

      window.npShowSection = showSection;

      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          if (target) showSection(target);
        });
      });

      showSection('sec-config');
    });
  </script>

    <!-- Supabase-Logik -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
    const $  = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

function isUUID(v) {
  return typeof v === 'string' &&
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v);
}

    let supa = null;
    let currentUser = null;
    let currentUserMeta = null;
    let currentProfile = null;
    let currentEvent = null;
    let allEvents = [];

    // -----------------------------
    // Supabase-Konfiguration
    // -----------------------------
    function loadConfig() {
      return {
        url: localStorage.getItem('sb_url') || '',
        key: localStorage.getItem('sb_key') || ''
      };
    }

    function saveConfig(url, key) {
      localStorage.setItem('sb_url', url || '');
      localStorage.setItem('sb_key', key || '');
    }

    function resetClient() {
      supa = null;
    }

  function ensureClient() {
  const { url, key } = loadConfig();
  if (!url || !key) {
    const msg = $('#conf-msg');
    if (msg) msg.textContent = 'Bitte Supabase-URL und Anon-Key speichern.';
    throw new Error('Supabase-Konfiguration fehlt');
  }
  supa = createClient(url, key, {
    auth: { storageKey: 'scout-app-auth', multiTab: false }
  });
  return supa;
}

    async function getClient() {
      if (supa) return supa;
      return ensureClient();
    }

    $('#btn-save-conf')?.addEventListener('click', () => {
      const url = ($('#sb-url')?.value || '').trim();
      const key = ($('#sb-key')?.value || '').trim();
      const msg = $('#conf-msg');
      if (!url || !key) {
        if (msg) msg.textContent = 'Bitte URL und Anon-Key eingeben.';
        return;
      }
      saveConfig(url, key);
      resetClient();
      if (msg) msg.textContent = 'Konfiguration gespeichert.';
    });

    $('#btn-test-conf')?.addEventListener('click', async () => {
      const msg = $('#conf-msg');
      if (msg) msg.textContent = 'Teste Verbindung‚Ä¶';

      const url = ($('#sb-url')?.value || '').trim();
      const key = ($('#sb-key')?.value || '').trim();
      if (url && key) {
        saveConfig(url, key);
        resetClient();
      }

      try {
        const c = await getClient();
        const { error } = await c.auth.getSession();
        if (error) {
          if (msg) msg.textContent = 'Fehler: ' + error.message;
        } else {
          if (msg) msg.textContent = 'OK: Verbindung funktioniert.';
        }
      } catch (e) {
        console.error(e);
        if (msg) msg.textContent = 'Verbindung fehlgeschlagen: ' + (e.message || e);
        resetClient();
      }
    });

    // -----------------------------
    // Auth & Jugendschutz
    // -----------------------------
    function updateAuthLockInfo() {
      const el = $('#auth-lock-info');
      const approvalBox = $('#auth-approval-link');
      if (!el) return;

      if (!currentUser) {
        el.innerHTML = '';
        if (approvalBox) approvalBox.innerHTML = '';
        return;
      }
      if (!currentUserMeta) {
        el.innerHTML = '‚ÑπÔ∏è Kein Altersprofil hinterlegt. Konto gilt als freigeschaltet (Testmodus).';
        return;
      }

      const year = currentUserMeta.birth_year;
      if (!year) {
        el.innerHTML = '‚ÑπÔ∏è Geburtsjahr fehlt im Profil.';
        return;
      }
      const nowYear = new Date().getFullYear();
      const age = nowYear - year;
      const minor = age < 16;

      if (minor && currentUserMeta.parent_required) {
        if (currentUserMeta.parent_approved) {
          el.innerHTML = `‚úÖ Konto freigeschaltet (minderj√§hrig, ca. ${age} Jahre, Elternzustimmung liegt vor).`;
        } else {
          el.innerHTML =
            `üîí Konto gesperrt (minderj√§hrig, ca. ${age} Jahre). ` +
            `Bitte Freigabelink an einen Erziehungsberechtigten senden.`;
        }
      } else if (minor) {
        el.innerHTML =
          `‚ÑπÔ∏è Minderj√§hrig (ca. ${age} Jahre) ‚Äì Elternzustimmung ist derzeit nicht als Pflicht markiert.`;
      } else {
        el.innerHTML =
          `‚úÖ Konto freigeschaltet (ca. ${age} Jahre, keine Elternzustimmung erforderlich).`;
      }
    }

    function isMinorLocked() {
      if (!currentUserMeta) return false;
      if (!currentUserMeta.parent_required) return false;
      const year = currentUserMeta.birth_year;
      if (!year) return false;
      const nowYear = new Date().getFullYear();
      const age = nowYear - year;
      return age < 16 && !currentUserMeta.parent_approved;
    }

    async function loadCurrentUser() {
      try {
        const c = await getClient();
        const { data } = await c.auth.getSession();
        currentUser = data?.session?.user || null;
        const elUser = $('#auth-user');
        if (elUser) {
          elUser.textContent = currentUser ? `Angemeldet: ${currentUser.email}` : '';
        }
      } catch (e) {
        console.error('loadCurrentUser', e);
        currentUser = null;
      }
    }

    async function loadUserMeta() {
      if (!currentUser) {
        currentUserMeta = null;
        updateAuthLockInfo();
        return;
      }
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('user_profile')
          .select('id, nickname, birth_year, parent_email, parent_required, parent_approved')
          .eq('id', currentUser.id)
          .maybeSingle();

        if (!error && data) {
          currentUserMeta = data;
        } else {
          currentUserMeta = null;
        }
      } catch (e) {
        console.error('loadUserMeta', e);
        currentUserMeta = null;
      }
      updateAuthLockInfo();
    }

    function generateToken() {
      const arr = new Uint8Array(16);
      crypto.getRandomValues(arr);
      return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function ensureApprovalLinkForCurrentUser() {
      const approvalBox = $('#auth-approval-link');
      if (!currentUser || !currentUserMeta || !approvalBox) return;

      const childId = currentUserMeta.id || currentUser.id;

      let email =
        currentUserMeta.parent_email ||
        ($('#reg-parent-email')?.value || '').trim() ||
        currentUser.email ||
        '';

      if (!email) {
        console.warn('ensureApprovalLinkForCurrentUser: keine Eltern-Mail gefunden.');
        return;
      }

      try {
        const c = await getClient();

        const { data, error } = await c
          .from('parental_consent')
          .select('token, email')
          .eq('child_id', childId)
          .maybeSingle();

        let token;
        if (!error && data && data.token) {
          token = data.token;
          email = data.email || email;
        } else {
          token = generateToken();
          const { error: insErr } = await c
            .from('parental_consent')
            .insert({
              child_id: childId,
              token,
              email
            });
          if (insErr) {
            console.error('ensureApprovalLinkForCurrentUser insert error', insErr);
            return;
          }
        }

        const base = window.location.origin + window.location.pathname.replace(/index\.html$/, '');
        const link = `${base}approve.html?token=${token}`;

        const subject = encodeURIComponent('Einwilligung f√ºr NextPlayer‚Ñ¢');
        const body = encodeURIComponent(
          `Hallo,\n\n` +
          `bitte klicken Sie auf folgenden Link, um die Nutzung der App NextPlayer‚Ñ¢ f√ºr Ihr Kind zu erlauben:\n\n` +
          `${link}\n\n` +
          `Viele Gr√º√üe\nNextPlayer‚Ñ¢`
        );

        approvalBox.innerHTML =
          `Freigabelink: <a href="${link}" target="_blank">${link}</a><br>` +
          `<a href="mailto:${encodeURIComponent(email)}?subject=${subject}&body=${body}">` +
          `E-Mail mit diesem Link √∂ffnen</a>`;
      } catch (e) {
        console.error('ensureApprovalLinkForCurrentUser', e);
      }
    }

    // Registrierung
    $('#btn-signup')?.addEventListener('click', async () => {
      const email       = ($('#auth-email')?.value || '').trim();
      const pwd         = ($('#auth-pass')?.value || '').trim();
      const nick        = ($('#reg-nick')?.value || '').trim();
      const yearStr     = ($('#reg-year')?.value || '').trim();
      const regRole     = ($('#reg-role')?.value || '').trim();
      const parentEmail = ($('#reg-parent-email')?.value || '').trim();
      const msg         = $('#auth-msg');
      const approvalBox = $('#auth-approval-link');

      if (msg) msg.textContent = '';
      if (approvalBox) approvalBox.innerHTML = '';

      if (!email || !pwd) {
        if (msg) msg.textContent = 'Bitte E-Mail & Passwort eingeben.';
        return;
      }
      if (!nick || !yearStr) {
        if (msg) msg.textContent = 'Bitte K√ºnstlername und Geburtsjahr ausf√ºllen.';
        return;
      }
      if (!regRole) {
        if (msg) msg.textContent = 'Bitte eine Rolle f√ºr das Konto ausw√§hlen.';
        return;
      }

      const birthYear = parseInt(yearStr, 10);
      const nowYear   = new Date().getFullYear();
      if (isNaN(birthYear) || birthYear < 2000 || birthYear > nowYear) {
        if (msg) msg.textContent = 'Geburtsjahr ist nicht plausibel.';
        return;
      }
      const age            = nowYear - birthYear;
      const parentRequired = age < 16;

      if (parentRequired && !parentEmail) {
        if (msg) msg.textContent = 'F√ºr U16 ist eine Eltern-E-Mail erforderlich.';
        return;
      }

      try {
        const c = await getClient();
        const { data, error } = await c.auth.signUp({ email, password: pwd });
        if (error) {
          if (msg) msg.textContent = 'Fehler: ' + error.message;
          return;
        }

        const user = data?.user;
        if (!user) {
          if (msg) msg.textContent = 'Registrierung gestartet ‚Äì bitte E-Mail best√§tigen.';
          return;
        }

        const { error: profErr } = await c
          .from('user_profile')
          .insert({
            id: user.id,
            nickname: nick,
            birth_year: birthYear,
            parent_email: parentEmail || null,
            parent_required: parentRequired,
            parent_approved: parentRequired ? false : true
          });

        if (profErr) {
          console.error('user_profile insert', profErr);
          if (msg) msg.textContent = 'Konto erstellt, aber Profil (Alter) konnte nicht gespeichert werden.';
          return;
        }

        const { error: prof2Err } = await c
          .from('profile')
          .upsert({
            user_id: user.id,
            role: regRole,
            club_name: null,
            extra_info: null
          }, { onConflict: 'user_id' });

        if (prof2Err) {
          console.error('profile insert error', prof2Err);
          if (msg) msg.textContent = 'Konto angelegt, aber Profil-Rolle konnte nicht gespeichert werden.';
          return;
        }

        if (parentRequired) {
          const token = generateToken();
          const contactEmail = parentEmail || email;

          const { error: consentErr } = await c
            .from('parental_consent')
            .insert({
              child_id: user.id,
              token,
              email: contactEmail
            });

          if (consentErr) {
            console.error('parental_consent insert error', consentErr);
            if (msg) msg.textContent =
              'Registrierung erfolgreich. Konto ist gesperrt, aber Freigabelink konnte nicht gespeichert werden.';
            return;
          }

          const base = window.location.origin + window.location.pathname.replace(/index\.html$/, '');
          const link = `${base}approve.html?token=${token}`;

          const subject = encodeURIComponent('Einwilligung f√ºr NextPlayer‚Ñ¢');
          const body = encodeURIComponent(
            `Hallo,\n\n` +
            `bitte klicken Sie auf folgenden Link, um die Nutzung der App NextPlayer‚Ñ¢ f√ºr Ihr Kind zu erlauben:\n\n` +
            `${link}\n\n` +
            `Viele Gr√º√üe\nNextPlayer‚Ñ¢`
          );

          if (approvalBox) {
            approvalBox.innerHTML =
              `Freigabelink: <a href="${link}" target="_blank">${link}</a><br>` +
              `<a href="mailto:${encodeURIComponent(contactEmail)}?subject=${subject}&body=${body}">` +
              `E-Mail mit diesem Link √∂ffnen</a>`;
          }

          if (msg) msg.textContent =
            'Registrierung erfolgreich. Konto ist gesperrt, bis ein Erziehungsberechtigter zugestimmt hat.';
        } else {
          if (msg) msg.textContent = 'Registrierung erfolgreich. Du kannst dich jetzt einloggen.';
        }

      } catch (e) {
        console.error(e);
        const msg = $('#auth-msg');
        if (msg) msg.textContent = 'Fehler bei Registrierung.';
      }
    });

    // Login
    $('#btn-login')?.addEventListener('click', async () => {
      const email = ($('#auth-email')?.value || '').trim();
      const pwd   = ($('#auth-pass')?.value || '').trim();
      const msg   = $('#auth-msg');
      const approvalBox = $('#auth-approval-link');

      if (approvalBox) approvalBox.innerHTML = '';

      if (!email || !pwd) {
        if (msg) msg.textContent = 'Bitte E-Mail & Passwort eingeben.';
        return;
      }

      try {
        const c = await getClient();
        const { data, error } = await c.auth.signInWithPassword({ email, password: pwd });

        if (error) {
          if (msg) msg.textContent = 'Login fehlgeschlagen: ' + error.message;
          return;
        }

        currentUser = data?.user || null;
        const elUser = $('#auth-user');
        if (elUser) elUser.textContent = `Angemeldet: ${currentUser?.email || email}`;

        await loadUserMeta();
        await loadProfile();
        await refreshAllData();

        const locked = isMinorLocked();

        if (locked) {
          if (msg) msg.textContent =
            'Login OK, aber dein Konto ist noch gesperrt (Elternzustimmung fehlt).';

          await ensureApprovalLinkForCurrentUser();

          if (window.npShowSection) {
            window.npShowSection('sec-auth');
          }
          return;
        }

        if (msg) msg.textContent = 'Login OK.';
        if (window.npShowSection) {
          window.npShowSection('sec-rating');
        }

      } catch (e) {
        console.error(e);
        const msg = $('#auth-msg');
        if (msg) msg.textContent = 'Fehler beim Login.';
      }
    });

    // Logout
    $('#btn-logout')?.addEventListener('click', async () => {
      try {
        const c = await getClient();
        await c.auth.signOut();
      } catch (e) {
        console.error('logout error', e);
      }

      currentUser = null;
      currentUserMeta = null;
      currentProfile = null;
      currentEvent = null;

      const msg         = $('#auth-msg');
      const approvalBox = $('#auth-approval-link');
      const elUser      = $('#auth-user');
      const lockInfo    = $('#auth-lock-info');

      if (msg)        msg.textContent = 'Abgemeldet.';
      if (elUser)     elUser.textContent = '';
      if (approvalBox) approvalBox.innerHTML = '';
      if (lockInfo)  lockInfo.textContent = '';

      const idsToClear = [
        'auth-email',
        'auth-pass',
        'reg-nick',
        'reg-year',
        'reg-parent-email'
      ];
      idsToClear.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
      });
      const regRoleSel = document.getElementById('reg-role');
      if (regRoleSel) regRoleSel.value = '';

      const profRoleSel = document.getElementById('prof-role');
      const profClub    = document.getElementById('prof-club');
      const profExtra   = document.getElementById('prof-extra');

      if (profRoleSel) {
        profRoleSel.value = '';
        profRoleSel.disabled = false;
      }
      if (profClub)  profClub.value  = '';
      if (profExtra) profExtra.value = '';

      updateAuthLockInfo();

      if (window.npShowSection) {
        window.npShowSection('sec-auth');
      }
    });

    // -----------------------------
    // Profil / Rolle (2b)
    // -----------------------------
    function updateProfileFormForRole() {
      const roleSel   = document.getElementById('prof-role');
      const clubLabel = document.getElementById('prof-club-label');
      const extraLabel= document.getElementById('prof-extra-label');

      if (!roleSel || !clubLabel || !extraLabel) return;

      const role = roleSel.value;

      clubLabel.textContent  = 'Verein (optional)';
      extraLabel.textContent = 'Zusatzinfo (optional)';

      if (role === 'spieler') {
        clubLabel.textContent  = 'Aktueller Verein (Pflicht)';
        extraLabel.textContent = 'Zusatzinfo Spieler (z.B. Position, Liga, optional)';
      } else if (role === 'trainer') {
        clubLabel.textContent  = 'Verein als Trainer (Pflicht)';
        extraLabel.textContent = 'Lizenzangabe (optional, z.B. ‚ÄûUEFA B‚Äú)';
      } else if (role === 'scout') {
        clubLabel.textContent  = 'Verein / Organisation als Scout (optional)';
        extraLabel.textContent = 'Weitere Infos (optional)';
      } else if (role === 'eltern') {
        clubLabel.textContent  = 'Verein des Kindes (optional)';
        extraLabel.textContent = 'Weitere Infos (optional)';
      } else if (role === 'zuschauer') {
        clubLabel.textContent  = 'Lieblingsverein (optional)';
        extraLabel.textContent = 'Weitere Infos (optional)';
      }
    }

    document.getElementById('prof-role')?.addEventListener('change', updateProfileFormForRole);

    async function saveProfile() {
      const msg       = document.getElementById('prof-msg');
      const roleSel   = document.getElementById('prof-role');
      const clubInput = document.getElementById('prof-club');
      const extraInput= document.getElementById('prof-extra');

      if (!currentUser) {
        if (msg) msg.textContent = 'Bitte zuerst einloggen.';
        return;
      }
      if (isMinorLocked()) {
        if (msg) msg.textContent = 'Dein Konto ist noch nicht freigeschaltet (Elternzustimmung fehlt).';
        return;
      }

      let role = roleSel?.value || '';
      if (!role && currentProfile && currentProfile.role) {
        role = currentProfile.role;
      }
      if (!role) {
        if (msg) msg.textContent = 'Bitte eine Rolle ausw√§hlen.';
        return;
      }

      const club_name  = (clubInput?.value || '').trim();
      const extra_info = (extraInput?.value || '').trim();

      if ((role === 'spieler' || role === 'trainer') && !club_name) {
        if (msg) msg.textContent = 'Bitte den Verein angeben (Pflicht f√ºr Spieler & Trainer).';
        return;
      }

      try {
        const c = await getClient();
        const payload = {
          user_id: currentUser.id,
          role,
          club_name:  club_name  || null,
          extra_info: extra_info || null
        };

        const { data, error } = await c
          .from('profile')
          .upsert(payload, { onConflict: 'user_id' })
          .select('user_id, role, club_name, extra_info')
          .single();

        if (error) {
          console.error('saveProfile error', error);
          if (msg) msg.textContent = 'Fehler beim Speichern des Profils.';
          return;
        }

        currentProfile = data;
        if (msg) msg.textContent = 'Profil gespeichert.';

        updateProfileFormForRole();
        if (window.npShowSection) {
          window.npShowSection('sec-rating');
        }
      } catch (e) {
        console.error('saveProfile', e);
        if (msg) msg.textContent = 'Fehler beim Speichern.';
      }
    }

    document.getElementById('btn-save-profile')?.addEventListener('click', saveProfile);

    async function loadProfile() {
      if (!currentUser) {
        currentProfile = null;
        return;
      }
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('profile')
          .select('user_id, role, club_name, extra_info')
          .eq('user_id', currentUser.id)
          .maybeSingle();

        if (!error && data) {
          currentProfile = data;

          const roleSel    = document.getElementById('prof-role');
          const clubInput  = document.getElementById('prof-club');
          const extraInput = document.getElementById('prof-extra');

          if (roleSel) {
            roleSel.value = data.role || '';
            if (data.role) {
              roleSel.disabled = true;
            }
          }
          if (clubInput)  clubInput.value  = data.club_name  || '';
          if (extraInput) extraInput.value = data.extra_info || '';

          updateProfileFormForRole();
        } else {
          currentProfile = null;
        }
      } catch (e) {
        console.error('loadProfile', e);
        currentProfile = null;
      }
    }

    // -----------------------------
    // Rating / Spieler / Events / Ranking / ICS / Verlauf
    // -----------------------------
    const ratingKeys = [
      ['technik','Technik'],
      ['taktik','Taktik'],
      ['intelligenz','Spielintelligenz'],
      ['handlung','Handlungsschnelligkeit'],
      ['mentalitaet','Mentalit√§t'],
      ['physis','Physis'],
      ['team','Teamverhalten'],
      ['konzentration','Konzentration'],
      ['kreativitaet','Kreativit√§t'],
      ['tempo','Spieltempo'],
      ['offensiv','Offensiv'],
      ['defensiv','Defensiv']
    ];
    const gradeSteps = ['1','1.5','2','2.5','3','3.5','4','4.5','5','5.5','6'];

    function gradeCells() {
      return gradeSteps.map(v => `<option value="${v}">${v}</option>`).join('');
    }

    function buildCriteriaUI() {
      const wrap = document.querySelector('#criteria');
      if (!wrap) return;
      wrap.innerHTML = '';
      ratingKeys.forEach(([key,label]) => {
        const div = document.createElement('div');
        div.style.minWidth = '150px';
        div.innerHTML = `
          <label>${label}</label>
          <select data-k="${key}">
            ${gradeCells()}
          </select>`;
        wrap.appendChild(div);
      });
    }
    buildCriteriaUI();

    async function createPlayer() {
      const msg = document.getElementById('player-create-msg');

      if (!currentUser) {
        if (msg) msg.textContent = 'Bitte zuerst einloggen.';
        return;
      }
      if (isMinorLocked()) {
        if (msg) msg.textContent = 'Dein Konto ist noch nicht freigeschaltet (Elternenzustimmung fehlt).';
        return;
      }

      const first = (document.getElementById('pl-first')?.value || '').trim();
      const last  = (document.getElementById('pl-last')?.value  || '').trim();
      const birth = (document.getElementById('pl-birth')?.value || '').trim();
      const clubCur  = (document.getElementById('pl-club-current')?.value || '').trim();
      const clubPrev = (document.getElementById('pl-club-prev')?.value   || '').trim();
      const posSel   = document.getElementById('pl-pos');
      const footSel  = document.getElementById('pl-foot');

      if (!first || !last) {
        if (msg) msg.textContent = 'Bitte mindestens Vor- und Nachname eingeben.';
        return;
      }

      const full = `${first} ${last}`.trim();
      const positions = posSel
        ? Array.from(posSel.selectedOptions).map(o => o.value)
        : [];

      try {
        const c = await getClient();

        const { data, error } = await c
          .from('player')
          .insert([{
            full_name: full,
            first_name: first,
            last_name: last,
            birthdate: birth || null,
            club_name: clubCur || null,
            prev_club: clubPrev || null,
            positions: positions.length ? positions : null,
            dominant_foot: footSel?.value || null
          }])
          .select('id')
          .single();

        if (error && error.code === '23505') {
          const { data: existing } = await c
            .from('player')
            .select('id')
            .eq('full_name', full)
            .eq('club_name', clubCur || null)
            .maybeSingle();

          const sel = document.getElementById('r-player');
          if (sel && existing?.id) {
            sel.value = existing.id;
          }

          if (msg) msg.textContent = 'Spieler existiert bereits ‚Äì wurde ausgew√§hlt.';
          return;
        }

        if (error) {
          console.error('createPlayer error', error);
          if (msg) msg.textContent = 'Fehler beim Speichern: ' + error.message;
          return;
        }

        if (msg) msg.textContent = 'Spieler gespeichert.';

        ['pl-first','pl-last','pl-birth','pl-club-current','pl-club-prev']
          .forEach(id => {
            const el = document.getElementById(id);
            if (el) el.value = '';
          });
        if (posSel) Array.from(posSel.options).forEach(o => (o.selected = false));
        if (footSel) footSel.value = '';

        await refreshPlayers();
        await refreshClubFilter?.();

        const sel = document.getElementById('r-player');
        if (sel && data?.id) {
          sel.value = data.id;
        }
      } catch (e) {
        console.error('createPlayer', e);
        if (msg) msg.textContent = 'Fehler beim Speichern: ' + (e.message || e);
      }
    }

    document.getElementById('btn-create-player')?.addEventListener('click', createPlayer);

    async function refreshPlayers() {
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('player')
          .select('id, full_name, club_name')
          .order('full_name');
        if (error) throw error;
        const sel = document.querySelector('#r-player');
        if (!sel) return;
        sel.innerHTML = (data || []).map(p =>
          `<option value="${p.id}">${p.full_name} (${p.club_name || ''})</option>`
        ).join('');
      } catch (e) {
        console.error('refreshPlayers', e);
      }
    }

    async function refreshClubFilter() {
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('player')
          .select('club_name');
        if (error) throw error;
        const clubs = Array.from(
          new Set(
            (data || [])
              .map(x => (x.club_name || '').trim())
              .filter(Boolean)
          )
        ).sort();
        const sel = document.querySelector('#club-filter');
        if (!sel) return;
        sel.innerHTML =
          '<option value="">Alle</option>' +
          clubs.map(cc => `<option value="${cc}">${cc}</option>`).join('');
      } catch (e) {
        console.error('refreshClubFilter', e);
      }
    }

    // Events aus echter DB (f√ºr Ranking / Verlauf), aber NICHT f√ºr Karte 3-Dropdown
    async function refreshEvents() {
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('event')
          .select('id, event_date, type, competition, opponent, subtype, location')
          .order('event_date', { ascending: false });
        if (error) throw error;
        allEvents = data || [];
      } catch (e) {
        console.error('refreshEvents', e);
      }
    }
 
            document.querySelector('#btn-add-rating')?.addEventListener('click', async () => {
      try {
        const c = await getClient();
        const sessionRes = await c.auth.getSession();
        const user = sessionRes?.data?.session?.user || null;
        const msg = document.querySelector('#rate-msg');

        if (!user) {
          const m = document.querySelector('#auth-msg');
          if (m) m.textContent = 'Bitte zuerst einloggen.';
          return;
        }
        if (isMinorLocked()) {
          if (msg) msg.textContent = 'Dein Konto ist noch nicht freigeschaltet (Elternzustimmung fehlt).';
          return;
        }

        if (!currentProfile || !currentProfile.role) {
          if (msg) msg.textContent = 'Bitte zuerst im Profil (2b) deine Rolle ausw√§hlen und speichern.';
          return;
        }

        const playerSel = document.querySelector('#r-player');
        const eventSel  = document.querySelector('#r-event');
        const commentEl = document.querySelector('#r-comment');

        const player_id = playerSel?.value || null;
        const dropdownEventId = eventSel?.value || null;
        let   event_id  = (currentEvent && currentEvent.id) ? currentEvent.id : dropdownEventId;

        if (!event_id) {
          if (msg) msg.textContent = 'Bitte zuerst ein Event ausw√§hlen (3b/3c oder Event-Dropdown).';
          return;
        }

        // falls currentEvent noch nicht gesetzt ist ‚Üí aus allEvents suchen
        if (!currentEvent && dropdownEventId) {
          let ev = allEvents.find(e => String(e.id) === String(dropdownEventId));
          if (ev) {
            setCurrentEvent(ev);
            event_id = ev.id;
          } else {
            console.warn('Kein DB-Event gefunden f√ºr ID', dropdownEventId);
          }
        }

        if (!player_id) {
          if (msg) msg.textContent = 'Bitte einen Spieler ausw√§hlen (oder in 2a neu anlegen).';
          return;
        }

        // üî¥ WICHTIG: nur echte UUIDs speichern ‚Äì keine Demo-IDs wie "E013"
        if (!isUUID(String(event_id))) {
          if (msg) msg.textContent =
            'Fehler: Dieses Event hat keine g√ºltige ID (z.B. Demo-Event ‚ÄûE013‚Äú). ' +
            'Bitte ein Event aus der Datenbank ausw√§hlen oder in 3c neu anlegen.';
          console.warn('Skip DB insert, invalid UUID for event_id:', event_id);
          return;
        }

        const comment = (commentEl?.value || '').trim();

        const crit = {};
        ratingKeys.forEach(([k]) => {
          const sel = document.querySelector(`select[data-k="${k}"]`);
          const v = parseFloat(sel?.value);
          crit[k] = isNaN(v) ? null : v;
        });

        const roleForRating = currentProfile.role || '';
        crit._role  = roleForRating;
        crit._rater = user.email || '';

        const payload = {
          rater_id: user.id,
          player_id,
          event_id,
          criteria: crit,
          comment
        };

        const { error } = await c
          .from('rating')
          .upsert(payload, {
            onConflict: 'rater_id,player_id,event_id'
          });

        if (error) {
          console.error('upsert rating error', error);
          if (msg) msg.textContent = 'Fehler: ' + error.message;
        } else {
          if (msg) msg.textContent = 'Bewertung gespeichert (ggf. aktualisiert).';
          await refreshRanking();
          await refreshLastComments();
        }
      } catch (e) {
        console.error('save rating', e);
        const msg = document.querySelector('#rate-msg');
        if (msg) msg.textContent = 'Fehler beim Speichern.';
      }
    });

        const roleForRating = currentProfile.role || '';
        crit._role  = roleForRating;
        crit._rater = user.email || '';

        const payload = {
          rater_id: user.id,
          player_id,
          event_id,
          criteria: crit,
          comment
        };

        const { error } = await c
          .from('rating')
          .upsert(payload, {
            onConflict: 'rater_id,player_id,event_id'
          });

        if (error) {
          console.error('upsert rating error', error);
          if (msg) msg.textContent = 'Fehler: ' + error.message;
        } else {
          if (msg) msg.textContent = 'Bewertung gespeichert (ggf. aktualisiert).';
          await refreshRanking();
          await refreshLastComments();
        }
      } catch (e) {
        console.error('save rating', e);
        const msg = document.querySelector('#rate-msg');
        if (msg) msg.textContent = 'Fehler beim Speichern.';
      }
    });

    function loadFavSet() {
      try {
        const raw = localStorage.getItem('fav_players') || '[]';
        const arr = JSON.parse(raw);
        return new Set(Array.isArray(arr) ? arr : []);
      } catch {
        return new Set();
      }
    }
    function saveFavSet(set) {
      localStorage.setItem('fav_players', JSON.stringify([...set]));
    }
    let favSet   = loadFavSet();
    let lastRows = [];
    let ratingsByPlayer = new Map();

    async function refreshRanking() {
      try {
        const c = await getClient();
        const [pRes, eRes, rRes] = await Promise.all([
          c.from('player').select('id, full_name, club_name, positions, dominant_foot, birthdate'),
          c.from('event').select('id, event_date, type, competition, opponent, subtype, location'),
          c.from('rating').select('player_id, event_id, criteria, created_at')
            .order('created_at', { ascending: false })
            .limit(2000)
        ]);

        if (pRes.error || eRes.error || rRes.error) {
          console.error(pRes.error || eRes.error || rRes.error);
          const msg = document.querySelector('#rank-msg');
          if (msg) msg.textContent = 'Fehler beim Laden des Rankings.';
          return;
        }

        const players = pRes.data || [];
        const events  = eRes.data || [];
        const ratings = rRes.data || [];

        const pMap = new Map(players.map(p => [p.id, p]));
        const eMap = new Map(events.map(e => [e.id, e]));

        const clubF   = document.querySelector('#club-filter')?.value || '';
        const posF    = document.querySelector('#rank-pos')?.value || '';
        const footF   = document.querySelector('#rank-foot')?.value || '';
        const typeF   = document.querySelector('#rank-type')?.value || '';
        const roleF   = (document.querySelector('#rank-role')?.value || '').toLowerCase();
        const fromF   = document.querySelector('#rank-from')?.value || '';
        const toF     = document.querySelector('#rank-to')?.value || '';
        const q       = (document.querySelector('#rank-q')?.value || '').toLowerCase();
        const minR    = parseInt(document.querySelector('#rank-min')?.value || '0', 10) || 0;
        const favMode = document.querySelector('#fav-filter')?.value || 'all';

        const agg = new Map();
        ratingsByPlayer = new Map();
        let rows = [];

        for (const r of ratings) {
          const ev = eMap.get(r.event_id);
          const pl = pMap.get(r.player_id);
          if (!ev || !pl) continue;

          const critObj = r.criteria || {};
          const roleVal = (critObj._role || '').toLowerCase();

          if (roleF && roleF !== 'alle' && roleVal !== roleF) continue;

          const d = (ev.event_date || '').slice(0, 10);

          if (typeF && ev.type !== typeF) continue;
          if (fromF && d < fromF) continue;
          if (toF   && d > toF)   continue;

          const vals = Object.entries(critObj)
            .map(([k, v]) => k.startsWith('_') ? NaN : Number(v))
            .filter(n => Number.isFinite(n));
          if (!vals.length) continue;

          const avg = vals.reduce((a, b) => a + b, 0) / vals.length;

          let list = ratingsByPlayer.get(r.player_id);
          if (!list) {
            list = [];
            ratingsByPlayer.set(r.player_id, list);
          }
          list.push({
            avg,
            created_at: r.created_at || '',
            event_date: ev.event_date || '',
            event_type: ev.type || '',
            event_name: formatEventPairing(ev),
            role:       critObj._role  || '',
            rater:      critObj._rater || ''
          });

          const key = r.player_id;
          let stat = agg.get(key);
          if (!stat) {
            stat = { sum: 0, cnt: 0, last: '0000-00-00' };
          }
          stat.sum  += avg;
          stat.cnt  += 1;
          if (d > stat.last) stat.last = d;
          agg.set(key, stat);
        }

        rows = [];
        for (const [playerId, st] of agg.entries()) {
          const pl = pMap.get(playerId) || {
            full_name: playerId,
            club_name: '',
            positions: null,
            dominant_foot: null,
            birthdate: null
          };
          const avg = st.sum / st.cnt;
          rows.push({
            id:    playerId,
            name:  pl.full_name,
            club:  pl.club_name || '',
            pos:   pl.positions || null,
            foot:  pl.dominant_foot || '',
            birth: pl.birthdate || '',
            cnt:   st.cnt,
            avg,
            last:  st.last
          });
        }

        rows = rows.filter(r => {
          const matchClub = !clubF || r.club === clubF;

          const posArr = Array.isArray(r.pos)
            ? r.pos
            : (typeof r.pos === 'string' && r.pos.length
              ? r.pos.split(',').map(x => x.trim()).filter(Boolean)
              : []);

          const matchPos  = !posF || posArr.includes(posF);
          const matchFoot = !footF || r.foot === footF;
          const matchText = !q || r.name.toLowerCase().includes(q) || r.club.toLowerCase().includes(q);
          const matchCnt  = r.cnt >= minR;
          const matchFav  = (favMode !== 'fav' || favSet.has(r.id));

          return matchClub && matchPos && matchFoot && matchText && matchCnt && matchFav;
        });

        rows.sort((a, b) => (a.avg - b.avg) || (b.cnt - a.cnt));
        const top = document.querySelector('#rank-top10')?.checked;
        if (top) rows = rows.slice(0, 10);

        lastRows = rows.slice();

        const tb = document.querySelector('#rank-table tbody');
        if (!tb) return;

        tb.innerHTML = rows.length
          ? rows.map(r => {
              const star   = favSet.has(r.id) ? '‚òÖ' : '‚òÜ';
              const posStr = Array.isArray(r.pos) ? r.pos.join(', ') : (r.pos || '');
              const footLabel =
                r.foot === 'left' ? 'links' :
                r.foot === 'right' ? 'rechts' :
                r.foot === 'both' ? 'beidf√º√üig' : '';
              return `<tr data-pid="${r.id}">
                        <td><span class="fav-toggle" data-pid="${r.id}" title="Watchlist an/aus">${star}</span></td>
                        <td>${r.name}</td>
                        <td>${r.club}</td>
                        <td>${posStr}</td>
                        <td>${footLabel}</td>
                        <td>${r.cnt}</td>
                        <td>${r.avg.toFixed(2)}</td>
                        <td>${r.last || ''}</td>
                      </tr>`;
            }).join('')
          : '<tr><td colspan="8">Keine Daten f√ºr die aktuellen Filter.</td></tr>';

        tb.querySelectorAll('.fav-toggle').forEach(el => {
          el.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const pid = el.getAttribute('data-pid');
            if (!pid) return;
            if (favSet.has(pid)) favSet.delete(pid);
            else favSet.add(pid);
            saveFavSet(favSet);
            refreshRanking();
          });
        });

        tb.onclick = (ev) => {
          const tr = ev.target.closest('tr[data-pid]');
          if (!tr) return;
          if (ev.target.classList.contains('fav-toggle')) return;

          const pid = tr.getAttribute('data-pid');
          const row = lastRows.find(r => String(r.id) === String(pid));
          if (!row) return;

          const pl = pMap.get(row.id) || {};
          const birthStr = pl.birthdate || '-';
          const footVal  = pl.dominant_foot || row.foot || '';
          const footLabel =
            footVal === 'left' ? 'links' :
            footVal === 'right' ? 'rechts' :
            footVal === 'both' ? 'beidf√º√üig' : (footVal || '-');
          const posStr   = Array.isArray(row.pos) ? row.pos.join(', ') : (row.pos || '');

          const details = ratingsByPlayer.get(row.id) || [];

          let detailText = '';
          if (details.length) {
            detailText =
              '\n\nEinzelbewertungen:\n' +
              details.map(d => {
                const date  = (d.event_date || '').slice(0,10);
                const typeShort =
                  d.event_type === 'match'      ? 'Sp.' :
                  d.event_type === 'training'   ? 'Tr.' :
                  d.event_type === 'tournament' ? 'Tu.' :
                  (d.event_type || '');

                const pairing = d.event_name || '';
                const role    = d.role  || '';
                const rater   = d.rater || '';
                const raterShort = rater.includes('@') ? rater.split('@')[0] : rater;

                return `- ${date} ${typeShort} ${pairing} | √ò ${d.avg.toFixed(2)} | Rolle: ${role} | Bew.: ${raterShort}`;
              }).join('\n');
          } else {
            detailText = '\n\nKeine Einzelbewertungen gefunden.';
          }

          alert(
            'Spieler: '      + row.name + '\n' +
            'Geb.: '         + birthStr + '\n' +
            'Verein: '       + row.club + '\n' +
            'Position(en): ' + posStr + '\n' +
            'Fu√ü: '          + footLabel + '\n' +
            'Bewertungen: '  + row.cnt + '\n' +
            '√ò Note: '       + row.avg.toFixed(2) +
            detailText
          );
        };

        const rankMsgLocal = $('#rank-msg');
        if (rankMsgLocal) rankMsgLocal.textContent = `OK: ${rows.length} Spieler`;
      } catch (e) {
        console.error('refreshRanking', e);
        const msg = $('#rank-msg');
        if (msg) msg.textContent = 'Fehler beim Laden des Rankings.';
      }
    }

    ['change', 'input'].forEach(evt => {
      [
        'club-filter',
        'rank-pos',
        'rank-foot',
        'rank-type',
        'rank-role',
        'rank-from',
        'rank-to',
        'rank-min',
        'rank-q',
        'fav-filter',
        'rank-top10'
      ].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener(evt, () => refreshRanking());
      });
    });
    document.getElementById('btn-refresh-ranking')?.addEventListener('click', () => refreshRanking());

    document.getElementById('btn-export-csv')?.addEventListener('click', () => {
      if (!lastRows.length) return;
      const header = ['Spieler','Verein','Position(en)','Fu√ü','#Bewertungen','√ò Note','Letztes Event'];
      const lines = [
        header.join(';'),
        ...lastRows.map(r =>
          [
            r.name,
            r.club,
            Array.isArray(r.pos) ? r.pos.join(', ') : (r.pos || ''),
            (r.foot === 'left' ? 'links' : r.foot === 'right' ? 'rechts' : r.foot === 'both' ? 'beidf√º√üig' : ''),
            r.cnt,
            r.avg.toFixed(2),
            r.last || ''
          ].join(';')
        )
      ];
      const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ranking.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    function parseICS(txt) {
      const out = [];
      const blocks = txt.split(/BEGIN:VEVENT/).slice(1).map(s => 'BEGIN:VEVENT' + s);
      for (const block of blocks) {
        const get = (k) => {
          const re = new RegExp('^' + k + '(?:;[^:]+)?:\\s*(.+)$','m');
          const m  = block.match(re);
          return m ? m[1].trim() : null;
        };
        let dt = get('DTSTART');
        if (!dt) {
          const m = block.match(/^DTSTART(?:;TZID=[^:]+)?:([0-9T]+)/m);
          if (m) dt = m[1];
        }
        if (!dt) continue;
        const raw = dt.replace(/[^0-9]/g,'').slice(0,8);
        if (raw.length < 8) continue;
        const event_date = `${raw.slice(0,4)}-${raw.slice(4,6)}-${raw.slice(6,8)}`;
        const summary  = get('SUMMARY')  || '';
        const location = get('LOCATION') || '';
        out.push({
          event_date,
          type:'match',
          subtype: summary.slice(0,120),
          competition:null,
          age_group:null,
          opponent:null,
          location:location.slice(0,120)
        });
      }
      return out;
    }

    document.getElementById('btn-import-ics')?.addEventListener('click', async () => {
      const c = await getClient().catch(e => {
        const m = $('#ics-msg');
        if (m) m.textContent = 'Nicht verbunden.';
        return null;
      });
      if (!c) return;
      const fileInput = document.getElementById('ics-file');
      const msg = document.getElementById('ics-msg');
      const file = fileInput?.files?.[0];
      if (!file) { if (msg) msg.textContent = 'Bitte eine .ics-Datei w√§hlen.'; return; }
      try {
        const txt = await file.text();
        const events = parseICS(txt);
        if (!events.length) { if (msg) msg.textContent = 'Keine VEVENTs gefunden.'; return; }
        const { error } = await c.from('event').insert(events);
        if (error) { console.error(error); if (msg) msg.textContent = 'Fehler: ' + error.message; }
        else { if (msg) msg.textContent = `OK ‚Äì ${events.length} Events importiert.`; refreshEvents(); }
      } catch (e) {
        console.error(e);
        const msg = document.getElementById('ics-msg');
        if (msg) msg.textContent = 'Fehler beim Import.';
      }
    });

    document.getElementById('btn-import-ics-url')?.addEventListener('click', async () => {
      const c = await getClient().catch(e => {
        const m = $('#ics-msg');
        if (m) m.textContent = 'Nicht verbunden.';
        return null;
      });
      if (!c) return;
      const msg  = document.getElementById('ics-msg');
      const url  = (document.getElementById('ics-url')?.value || '').trim();
      if (!url) { if (msg) msg.textContent = 'Bitte eine ICS-URL eingeben.'; return; }
      try {
        const res = await fetch(url, { redirect:'follow' });
        if (!res.ok) throw new Error(res.statusText);
        const txt = await res.text();
        const events = parseICS(txt);
        if (!events.length) { if (msg) msg.textContent = 'Keine VEVENTs gefunden.'; return; }
        const { error } = await c.from('event').insert(events);
        if (error) { console.error(error); if (msg) msg.textContent = 'Fehler: ' + error.message; }
        else { if (msg) msg.textContent = `OK ‚Äì ${events.length} Events importiert.`; refreshEvents(); }
      } catch (e) {
        console.error(e);
        if (msg) msg.textContent = 'Fehler beim Laden. Nutze ggf. Download + Datei-Import.';
      }
    });

    async function refreshLastComments() {
      try {
        const c = await getClient();
        const { data, error } = await c
          .from('rating')
          .select('id, player_id, event_id, comment, created_at')
          .order('created_at', { ascending:false })
          .limit(5);
        if (error) throw error;
        const pMap = new Map();
        const eMap = new Map();
        const idsP = Array.from(new Set((data||[]).map(r => r.player_id).filter(Boolean)));
        const idsE = Array.from(new Set((data||[]).map(r => r.event_id).filter(Boolean)));
        if (idsP.length) {
          const pr = await c.from('player').select('id, full_name').in('id', idsP);
          (pr.data||[]).forEach(p => pMap.set(p.id, p.full_name));
        }
        if (idsE.length) {
          const er = await c.from('event').select('id, event_date, subtype, competition, opponent').in('id', idsE);
          (er.data||[]).forEach(ev => {
            let name = '';
            if (ev.competition || ev.opponent) {
              name = `${ev.competition || ''} - ${ev.opponent || ''}`.trim();
            } else if (ev.subtype) {
              name = ev.subtype;
            } else {
              name = ev.event_date || '';
            }
            eMap.set(ev.id, `${ev.event_date || ''} ${name}`);
          });
        }
        const box = document.getElementById('last-ratings');
        if (!box) return;
        box.innerHTML = (data||[]).length
          ? (data||[]).map(r => {
              const pn = pMap.get(r.player_id) || r.player_id;
              const en = eMap.get(r.event_id) || '';
              const ctext = (r.comment || '').substring(0,120);
              return `<tr>
                        <td>${(r.created_at||'').slice(0,10)}</td>
                        <td>${pn}</td>
                        <td>${en}</td>
                        <td>${ctext}</td>
                      </tr>`;
            }).join('')
          : '<tr><td colspan="4">Noch keine Bewertungen.</td></tr>';
      } catch (e) {
        console.error('refreshLastComments', e);
      }
    }

    async function createEvent() {
      const dateEl   = document.getElementById('event-date');
      const typeEl   = document.getElementById('event-type');
      const homeEl   = document.getElementById('event-home');
      const awayEl   = document.getElementById('event-away');
      const nameEl   = document.getElementById('event-name');
      const locEl    = document.getElementById('event-location');
      const msg      = document.getElementById('event-create-msg');

      if (!currentUser) {
        if (msg) msg.textContent = 'Bitte zuerst einloggen.';
        return;
      }
      if (isMinorLocked()) {
        if (msg) msg.textContent = 'Dein Konto ist noch nicht freigeschaltet (Elternzustimmung fehlt).';
        return;
      }

      const event_date = (dateEl?.value || '').trim();
      const type       = (typeEl?.value || '').trim();

      const competition = (homeEl?.value || '').trim();
      const opponent    = (awayEl?.value || '').trim();
      const subtype     = (nameEl?.value || '').trim();
      const location    = (locEl?.value || '').trim();

      if (!event_date || !type) {
        if (msg) msg.textContent = 'Bitte mindestens Datum und Event-Typ eingeben.';
        return;
      }

      try {
        const c = await getClient();

        const { data, error } = await c
          .from('event')
          .insert([{
            event_date,
            type,
            competition,
            opponent,
            subtype,
            location
          }])
          .select();

        if (error) {
          console.error('createEvent error', error);
          if (msg) msg.textContent = 'Fehler beim Speichern: ' + error.message;
          return;
        }

        if (msg) msg.textContent = 'Event gespeichert.';

        if (homeEl) homeEl.value = '';
        if (awayEl) awayEl.value = '';
        if (nameEl) nameEl.value = '';
        if (locEl)  locEl.value  = '';

        await refreshEvents();
        if (data && data.length) {
          setCurrentEvent(data[0]);
        }
      } catch (e) {
        console.error('createEvent', e);
        if (msg) msg.textContent = 'Fehler beim Speichern.';
      }
    }

    document.getElementById('btn-create-event')?.addEventListener('click', createEvent);

async function searchEventsByTerm(term) {
  try {
    const c = await getClient();

    let query = c
      .from('event')
      .select('id, event_date, type, competition, opponent, subtype, location')
      .order('event_date', { ascending: false })
      .limit(50);

    term = (term || '').trim();
    if (term) {
      const orFilter =
        `competition.ilike.%${term}%,` +
        `opponent.ilike.%${term}%,` +
        `subtype.ilike.%${term}%,` +
        `location.ilike.%${term}%`;
      query = query.or(orFilter);
    }

    const { data, error } = await query;
    if (error) throw error;

    // Duplikate nach Inhalt entfernen
    const unique = [];
    const seen = new Set();
    for (const ev of data || []) {
      const key = [
        ev.event_date || '',
        ev.type || '',
        ev.competition || '',
        ev.opponent || '',
        ev.location || ''
      ].join('|');
      if (seen.has(key)) continue;
      seen.add(key);
      unique.push(ev);
    }

    renderEventResults(unique);
  } catch (e) {
    console.error('searchEventsByTerm', e);
    const box = document.querySelector('#event-results');
    if (box) box.textContent = 'Fehler bei der Suche.';
  }
}
    
    function formatEventPairing(ev) {
      if (ev.competition || ev.opponent) {
        const home = (ev.competition || '').trim();
        const away = (ev.opponent || '').trim();
        if (home && away) return `${home} - ${away}`;
        if (home) return home;
        if (away) return away;
      }
      if (ev.subtype) return ev.subtype;
      return `Event ${ev.id}`;
    }

    function formatEventDisplayLine(ev) {
      const parts = [];
      if (ev.event_date) parts.push(ev.event_date);
      if (ev.type)       parts.push(ev.type);
      const pairing = formatEventPairing(ev);
      if (pairing)      parts.push(pairing);
      if (ev.location)  parts.push(ev.location);
      return parts.join(' | ');
    }

    function renderEventResults(list) {
      const box = document.querySelector('#event-results');
      const label = document.querySelector('#event-current');
      const card  = document.querySelector('#event-card');
      if (!box) return;

      if (!list.length) {
        box.textContent = 'Keine Spiele gefunden.';
        if (label) label.textContent = 'Kein Spiel ausgew√§hlt.';
        if (card) {
          card.innerHTML = '<p style="margin:0; color:#555;">Kein Spiel ausgew√§hlt.</p>';
        }
        return;
      }

      const ul = document.createElement('ul');
      ul.style.listStyle = 'none';
      ul.style.padding = '0';
      ul.style.margin = '0';

      list.forEach(ev => {
        const li = document.createElement('li');
        li.style.marginBottom = '6px';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.style.padding = '4px 8px';
        btn.style.cursor = 'pointer';
        btn.style.width = '100%';
        btn.style.textAlign = 'left';

        btn.textContent = formatEventDisplayLine(ev);

        btn.addEventListener('click', () => {
          setCurrentEvent(ev);
        });

        li.appendChild(btn);
        ul.appendChild(li);
      });

      box.innerHTML = '';
      box.appendChild(ul);
    }

    function setCurrentEvent(ev) {
      currentEvent = ev;

      const label = document.querySelector('#event-current');
      if (label) {
        let pairing = '';
        if (ev.competition || ev.opponent) {
          pairing = `${ev.competition || ''} - ${ev.opponent || ''}`.trim();
        } else if (ev.subtype) {
          pairing = ev.subtype;
        } else {
          pairing = `Event ${ev.id}`;
        }
        const dateStr = ev.event_date ? ` am ${ev.event_date}` : '';
        label.textContent = `Aktuell ausgew√§hltes Spiel: ${pairing}${dateStr}`;
      }

      const card = document.querySelector('#event-card');
      if (card && ev) {
        const pairing = formatEventPairing(ev);
        const dateStr = ev.event_date || '';
        const typeStr = ev.type || '';
        const locStr  = ev.location || '';
        const extra   = ev.subtype || '';

        card.innerHTML = `
          <div style="font-size:0.95rem; font-weight:600; margin-bottom:4px;">
            ${pairing}
          </div>
          <div style="font-size:0.85rem; color:#555; margin-bottom:2px;">
            Datum: ${dateStr}
          </div>
          <div style="font-size:0.85rem; color:#555; margin-bottom:2px;">
            Typ: ${typeStr}${extra ? ' (' + extra + ')' : ''}
          </div>
          <div style="font-size:0.85rem; color:#555; margin-bottom:2px;">
            Ort: ${locStr}
          </div>
          <div style="font-size:0.8rem; color:#777;">
            Event-ID: ${ev.id}
          </div>
        `;
      }

      const sel = document.querySelector('#r-event');
      if (sel && ev.id) {
        const opt = sel.querySelector(`option[value="${ev.id}"]`);
        if (opt) sel.value = String(ev.id);
      }
    }

    const inpPairing = document.querySelector('#search-pairing');
    const btnSearchEvent = document.querySelector('#btn-search-event');

    if (btnSearchEvent && inpPairing) {
      btnSearchEvent.addEventListener('click', () => {
        const term = (inpPairing.value || '').trim();
        searchEventsByTerm(term);
      });

      inpPairing.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const term = (inpPairing.value || '').trim();
          searchEventsByTerm(term);
        }
      });
    }

    const selEvent = document.querySelector('#r-event');
    if (selEvent) {
      selEvent.addEventListener('change', () => {
        const id = selEvent.value;
        let ev = allEvents.find(e => String(e.id) === id);
        if (!ev) {
          ev = MOCK_EVENTS.find(e => String(e.id) === id);
        }
        if (ev) setCurrentEvent(ev);
      });
    }

    async function refreshAllData() {
      await Promise.all([refreshPlayers(), refreshEvents(), refreshClubFilter()]);
      await refreshRanking();
      await refreshLastComments();
    }

    (async function init() {
      const cfg = loadConfig();
      const urlInput = document.getElementById('sb-url');
      const keyInput = document.getElementById('sb-key');
      if (urlInput) urlInput.value = cfg.url;
      if (keyInput) keyInput.value = cfg.key;

      if (cfg.url && cfg.key) {
        try {
          await getClient();
          const rankMsg = $('#rank-msg');
          if (rankMsg) rankMsg.textContent = 'Bereit (bitte einloggen).';
          if (window.npShowSection) {
            window.npShowSection('sec-auth');
          }
        } catch (e) {
          console.error('init', e);
        }
      }
    })();
  </script>
</body>
</html>
